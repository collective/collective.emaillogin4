Introduction
============

This is a temporary package with some fixes for when you want to use
the email address as login name in Plone 4.  Emaillogin in Plone 4
should work fine out of the box without this package.  Some
improvements would be useful though that need some more careful
consideration before being added to core Plone.


Plone version
-------------

This package is tested with and developed for Plone 4.2.  It is
probably fine to use in 4.0, 4.1 and 4.3 too.

For Plone 3, use the ``collective.emaillogin`` package.


What does this package do?
--------------------------

Or at least, what should it do when it is ready?


Clearer separation between user id and login name
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The validation of the ``register`` browser view uses two methods to
get a user id and login name::

    # Generate a nice user id and store that in the data.
    user_id = self.generate_user_id(data)
    # Generate a nice login name and store that in the data.
    login_name = self.generate_login_name(data)

After this, the ``data`` dictionary will have keys ``user_id`` and
``login_name`` set accordingly.

We avoid as much as possible the use of ``username`` as a variable,
because no one ever knows if that is meant as a user id or as a login
name.  In standard Plone this is always the same, but this need not be
true, especially when using the email address as login name.

These changes are intended to be merged to ``plone.app.users``.


Control over user ids
~~~~~~~~~~~~~~~~~~~~~

An ``IUserIdGenerator`` interface is defined.  This is used in the new
``generate_user_id`` method of the ``register`` browser view (also
used when adding a new user as admin).

In ``generate_user_id`` we try a few options for coming up with a good
user id:

1. We query a utility, so integrators can register a hook to
   generate a user id using their own logic::

     generator = queryUtility(IUserIdGenerator)
     if generator:
         userid = generator(data)
         if userid:
             data['user_id'] = userid
             return userid

2. If a username is given and we do not use email as login,
   then we simply return that username as the user id.

3. We create a user id based on the full name, if that is
   passed.  This may result in an id like ``bob-jones-2``.

When the email address is used as login name, we originally
used the email address as user id as well.  This has a few
possible downsides, which are the main reasons for the new,
pluggable approach:

- It does not work for some valid email addresses.

- Exposing the email address in this way may not be wanted.

- When the user later changes his email address, the user id
  will still be his old address.  It works, but may be
  confusing.

Another possibility would be to simply generate a uuid, but that is
ugly.  We could certainly try that though: the big plus here would be
that you then cannot create a new user with the same user id as a
previously existing user if this ever gets removed.  If you would get
the same id, this new user would get the same global and local roles,
if those have not been cleaned up.

When a user id is chosen, the 'user_id' key of the data gets
set and the user id is returned.

These changes are intended to be merged to ``plone.app.users``.


Control over login names
~~~~~~~~~~~~~~~~~~~~~~~~

Similarly, an ``ILoginNameGenerator`` interface is defined.

Usually the login name and user id are the same, but this is
not necessarily true.  When using the email address as login
name, we may have a different user id, generated by calling
the generate_user_id method.

We try a few options for coming up with a good login name:

1. We query a utility, so integrators can register a hook to
   generate a login name using their own logic::

     pas = getToolByName(self.context, 'acl_users')
     generator = queryUtility(ILoginNameGenerator)
     if generator:
         login_name = generator(data)
         if login_name:
             login_name = pas.applyTransform(login_name)
             data['login_name'] = login_name
           return login_name

2. If a username is given and we do not use email as login,
   then we simply return that username as the login name.

3. When using email as login, we use the email address.

In all cases, we call PAS.applyTransform on the login name, if
that is defined.  This is a recent addition to PAS, currently
under development.

When a login name is chosen, the 'login_name' key of the data gets
set and the login name is returned.

These changes are intended to be merged to ``plone.app.users``.


Lowercase login names
~~~~~~~~~~~~~~~~~~~~~

We store login names as lowercase.  The email addresses themselves can
actually be mixed case, though that is not really by design, more a
(happy) circumstance.

This needs branch ``maurits-login-transform`` of
``Products.PluggableAuthService``.  That branch introduces a property
``login_transform``.  Setting this to ``lower`` the ``lower`` method
of PAS is called whenever a login name is given.

All relevant places in ``plone.app.users`` have been changed to take
this new property into account, using code like this::

  login_name = pas.loginTransform(login_name)

In the security panel of ``plone.app.controlpanel`` we change the
``set_use_email_as_login`` method to set ``login_transform`` to lower
case when switching on email as login name.

- TODO: change migration EmailView from plone.app.controlpanel.
  Should be lots easier now.  Maybe do this automatically when
  switching on emaillogin in the security panel.


Set own login name
------------------

The ``Products.CMFPlone.utils.set_own_login_name`` method id
drastically simplified, with the former code being moved to PAS
itself::

  def set_own_login_name(member, loginname):
      """Allow the user to set his/her own login name.
      """
      pas = getToolByName(member, 'acl_users')
      pas.updateOwnLoginName(loginname)
